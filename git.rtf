{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset0 Arial;}}
{\colortbl ;\red155\green0\blue211;\red255\green0\blue0;\red0\green0\blue0;\red128\green0\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl240\slmult1\b\f0\fs22\lang9 GIT\b0 :GIT is distributed version control system.\par
To create the configuration:\b\par
git config \tab\tab -->\b0 will give list of variables\par
\b git config --global --list  \tab\tab -->\b0 gives the list of existing login credentials\par
\b git config --global user.name "veena"  -->\b0 set the user name.if the same command is given,overwrites the existing credentials\par
\b git config --global user.email "veenanjalitammina999@gmail.com"   -->\b0 to set the email\par
\b git config --global --get user.name\tab ->\b0 give the user name\par
\b git config --global --get user.email       ->\b0 give the email\b\par
git init\tab\tab -->\b0 Transform the current directory into a Git repository. This adds a .git subdirectory to the current directory .By default it creates in master branch.\b\par
git init <directory>   -->\b0 create a new subdirectory called \lang1033 <\lang9 directory\lang1033 >\lang9 containing nothing but the .git subdirectory.\par
\b git init <directory> --template=<template_directory>\tab -->  \b0 --template option allows you to specify a directory to use as a template when initializing a new Git repository.\b\par
git status\tab\tab -->\b0 will give the status of the repository\par
\b git init -b main\tab\tab -->\b0 creates local repository in main branch.(creates a hidden .git folder where staging area and commits will be present there)(b->branch)\par
#To commit the changes, the file should be in staging area,for staging "\b add"\b0  is used\par
\b git add file1.txt\tab\tab -->\b0 will add the file to staging environment but not committed\par
\b git log\tab\tab\tab -->\b0 will show all the commits\par
\b git commit -m "message that specify what features are added"  \par
\cf1\b0 #for each commit, checksum(14 digit hexadecimal value,only first seven digits will be displayed)\b  \b0 will be given\b .\par
\cf0\b0 #Everytime the changes are made,the file should commit.To commit the file directly by skipping the staging,use -a\par
\b git commit -a -m "file moves from working directory to commit without moving to staging \b0 area"                                   # \b -\b0 a option doesn't require a separate git add step before committing\b .\b0\par
\b git diff   #\b0 give the changes that are made before adding the file to staging area.If the file is added using 'add' then diff won't show wany changes.\par
\b git diff -staged     \b0 #give the changes that are made in staging area\par
\b git add .      \b0\tab   #add all the files to the staging area\par
\b git rm --cached file.txt    \b0 #remove the file from git\par
\b git commit -m "removed the file"\par
git rev-list --count HEAD   #\b0 to get the count of commits\par
\b git rev-list --count <branch-name>  #\b0 for each branch\par
\b\par
git branch -M main      \b0 #creating a main branch\par
#settingup ssh\par
\b ssh-keygen -o  #\b0 generates the key and asks the filename to save the key.default stores in id_rsa.pub file in .ssh folder.\par
\b git remote add origin sshurlofrepo  #\b0 here instead of ssh url https url can also be given,but for https url it asks for the authentication\b\par
git push -u origin main\tab             \b0 #push the repository from local machine to remote repository\par
\cf1 #\b after pushing into remote repository,if any changes made to local macine repository,then the repository need to push again to remote repository to commit \cf2\par
\cf3 git remote -v\tab\tab\tab #\cf2 checking existing remotes\cf3\par
git remote remove origin\tab #\b0 remove the origin remote\cf0\par
\b git tag v1.0 -m "release1"\tab #\b0 adds the tag to local repository\par
\b git tag   \tab\tab\tab\tab\b0 #shows  the list of tags\par
\b git push origin v1.0\tab\tab #\b0 adds the tag to remote repository\par
\b git show v1.0 \tab\tab\tab #\b0 shows info about version v1.0\par
\b git log --pretty=oneline\tab #\b0 give the short logs of commits\par
\b git switch -c feature1\tab\tab #creating new branch named feature1,no limit in creating branches.\par
git switch main\tab\tab\tab #switch to main branch\par
git branch \tab\tab\tab #\b0 gives the list of branches and highlight the active branch\par
\b git branch -all\b0\tab\tab\tab #gives the list of branches in local machine along with remote repository\par
\b git switch - \tab\tab\tab #\b0 changes to previous branch\par
#assume that you are in the main branch,and repoitory has feature branch,now to merge feature branch into main ,you should be in main branch and execute the following command.Before pushing, pull the main branch from main repository and do merging.After merging push it back to the remote repository\par
\b git merge feature\tab #\b0 merging feature branch in main\b\tab\par
git show:file1.txt\tab\tab #\b0 shows the contents of previous version\b\par
git show <commit_hash>:file1.txt\tab #\b0 shows the content of specified commit hash\par
\b git clone <repo url>\tab\tab\tab #\b0 create a copy of remote repositories\b\par
\b0\par
\cf2\b\fs28 counting commits:\par
\cf0\b0\fs22 to count all commits in the current branch (assuming you are on the master branch),\par
\b git rev-list --count HEAD                   #\b0 to count all the commits in the current branch\par
\b git rev-list --count HEAD -- <file_path>   #\b0 Count commits for a specific file:\par
\b git rev-list --count <branch_name>   #\b0 Count commits for a specific branch:\par
\cf2\b\fs32 git config levels\tab :\par
\cf1\fs24  --local\par
\cf0\b0\fs22 By default, git config will write to a local level if no configuration option is passed.Local configuration values are stored in a file that can be found in the repo's .git directory: .git/config \b\tab\b0\par
\cf1\b\fs24 --global\par
\cf0\b0\fs22 Global level configuration is user-specific, meaning it is applied to an operating system user. Global configuration values are stored in a file that is located in a user's home directory. ~ /.gitconfig on unix systems and C:\\Users\\\\.gitconfig on windows \b\par
\cf1\fs24\par
 --system\par
\cf0\b0\fs22 System-level configuration is applied across an entire machine. This covers all users on an operating system and all repos. The system level configuration file lives in a gitconfig file off the system root path. \par
\par
\cf2\b\fs28 configuring editor for git\cf0 :\par
\fs22 git config --global core.editor <editor-name>\par
\b0 git config --global core.editor vim  #setting vim as editor\par
\b git config --get core.editor\b0\tab\tab #to get the current configured editor\par
\b git config --global --unset core.editor   #\b0 unset the currently configured editor\par
\par
\b\par
\cf2\fs28 Merging up branches\cf0 :\par
\fs22 git merge <source-branch>\tab\tab #\b0 to execute this you should be in the taget branch\par
If there are no conflicts, Git will automatically perform the merge. If there are conflicts, Git will mark the conflicted files, and you'll need to resolve the conflicts manually.\par
\b git merge --abort\tab\tab\tab #\b0 aborts the merge process\b\par
\b0 When you perform a merge in Git, the branch being merged is typically not automatically deleted. Git does not automatically delete branches after a merge\par
# Delete the merged branch locally\b\par
git branch -d <branch-name>\b0\par
If you have already pushed the merged branch to a remote repository and you want to delete it there:\par
 # Delete the merged branch on the remote repository\par
\b git push origin --delete <branch-name>\par
\par
\cf2\fs28 Colored outputs\par
\cf0\b0\fs22 git config command is used to set these color values.\par
\b color.ui\tab\tab -->\b0 mastervariable to set git colors.setting it to false  disable all Git's colored terminal output.\par
By default, color.ui is set to auto which will apply colors to the immediate terminal output stream. The auto setting will omit color code output if the output stream is redirected to a file or piped to another process.\par
You can set the color.ui value to always which will also apply color code output when redirecting the output stream to files or pipes\par
\par
\b git reset HEAD --\par
\b0 This command unstages all changes that have been added to the index (staging area). The double hyphen (--) is used to indicate the end of options and is typically not necessary in this context, but it's a good practice to include it to avoid ambiguity.\par
\par
\cf2\b\fs28 Creating alias\par
\cf0\b0\fs22 Aliases can be created through two primary methods:\par
\b 1\cf1 )Directly editing Git config files\cf0\b0 :The global or local config files can be manually edited and saved to create aliases. The global config file lives at $HOME/.gitconfig file path. The local path lives within an active git repository at /.git/config\par
\b 2\cf1 )Using the git config to create aliases\cf2\fs28\par
\cf0\fs22 git config --global alias.<alias-name> '<git-command>'\tab\tab\par
Ex:git config --global alias.co checkout\tab\tab #\b0 alias created for checkout command\cf2\b\fs28\par
\cf0\fs22 git config --global alias.unstage 'reset HEAD --'\tab\tab #\b0 alias createdfor unstaging\b\par
\b0\par
\cf2\b\fs24 Removing untracked files\cf0\fs22 :\par
\b0 To remove untracked files, you can use git clean:\par
\b git clean -fd\par
\b0 This will remove untracked files and directories (-f for force, -d for removing directories).\par
\par
\cf2\b\fs28 git checkout\par
\cf0\b0\fs22 If you have modifications in your working directory that are not yet staged (unstaged changes) and you want to discard them, you can use the git checkout command to revert the changes. \par
git checkout to remove changes from a modified file in your working directory. However, git checkout is generally used to switch branches, and using it to remove changes requires a specific syntax\b .\par
git checkout -- file.txt\par
\b0 Replace file.txt with the name of the file for which you want to discard the unstaged changes.\par
#To remove all unstaged changes in your working directory (for all files), you can use:\par
\b git checkout -- .\par
\b0 The . indicates the current directory, and this command will revert all unstaged changes.\par
\par
\cf4\b\fs24 # Unstaged changes\par
git reset HEAD -- file.txt\par
\par
# Discard unstaged changes in working directory\par
git checkout -- file.txt\par
\cf0\fs22\par
git add .\tab\tab #\b0 add all the files in current dirctory to the staging area \par
\par
\cf2\b\fs28 git commit -ammend\cf0\b0\fs22\par
The git commit --amend command is used to modify the most recent commit in Git. When you run this command, it allows you to make changes to the previous commit message.\par
\par
\cf2\b\fs28 git diff\par
\cf0\b0\fs22 The git diff HEAD ./path/to/file command is used to view the changes made to a specific file in the working directory compared to the most recent commit (HEAD)\par
git diff: Initiates the diff command in Git.\par
HEAD: Refers to the most recent commit on the current branch. It's the commit that HEAD is currently pointing to.\par
./path/to/file: Specifies the path to the specific file you want to examine.\par
\par

\pard\sa200\sl240\slmult1\tx3510\cf2\b\fs28 git diff --staged   ==  git diff --cached\cf0\b0\fs22\par
This command is an alternative way of expressing the same concept as git diff --cached.            It also shows the changes that are staged but not yet committed.\par
\cf1\b\fs24 git diff without a file path will compare changes across the entire repository\cf0\b0\fs22 .\cf1\b\fs24 By default git diff will show you any uncommitted changes since the last commit.\par
\cf0 #Comparing 2 branches\cf1\par
\cf0\fs22 git diff branch1 branch2\par
\par
\cf2\f1\fs28 git stash\cf0\f0\fs22 :\par
\b0 The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy. For example:\b\par
git stash apply\par
\b0 If conflicts occur, Git will mark the conflicted areas in the affected files.Resolving conflicts involves manually editing the files to merge the changes. Here's a step-by-step guide on how to resolve conflicts after applying a stash:\par
\b git add <conflicted_file>    \b0 #add the conflicted file\b\par
git stash drop                          \b0 #complete the process by removing the stash\par
\par
##  If you created a new file after stashing changes and then dropped the stash, the changes from the stash will not be applied, but the new file you created will remain in your working directory.\par
\b git stash apply\par

\pard\sa200\sl240\slmult1 touch new_file.txt\par
git stash drop\par
\b0 After these steps, the changes from the stash, including modifications to existing files, will not be reapplied to your working directory. However, the new file (new_file.txt) that you created after stashing will remain in your working directory.\par
\b\par
\b0\par
}
 